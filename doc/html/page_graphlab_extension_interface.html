<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GraphLab Create SDK API: GraphLab Create Extension Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab Create SDK API
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_graphlab_extension_interface.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">GraphLab Create Extension Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_function_extension_interface">Function Extension Interface</a><ul><li class="level2"><a href="#sec_function_graphlab_includes">GraphLab Includes</a></li>
<li class="level2"><a href="#page_extension_interface_cpp_fn_impl">Function Implementation</a><ul><li class="level3"><a href="#sec_function_exceptions">Exceptions</a></li>
<li class="level3"><a href="#sec_supported_type_list_examples">Examples</a></li>
</ul>
</li>
<li class="level2"><a href="#sec_function_publishing">Publishing Functions</a></li>
<li class="level2"><a href="#sec_function_compilation">Compilation</a></li>
<li class="level2"><a href="#sec_function_python_import">Python Import</a><ul><li class="level3"><a href="#sec_function_python_import_hook">Import Hook</a></li>
<li class="level3"><a href="#sec_function_python_ext_import">ext_import</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#sec_class_extension_interface">Class Extension Interface</a><ul><li class="level2"><a href="#sec_class_graphlab_includes">GraphLab Includes</a></li>
<li class="level2"><a href="#page_extension_interface_cpp_class_impl">Class Implementation</a><ul><li class="level3"><a href="#sec_class_exceptions">Exceptions</a></li>
</ul>
</li>
<li class="level2"><a href="#sec_class_publishing">Publishing Classes</a><ul><li class="level3"><a href="#sec_class_member_publishing">Class Member Registration</a></li>
</ul>
</li>
<li class="level2"><a href="#sec_class_compilation">Compilation And Python Import</a></li>
<li class="level2"><a href="#sec_class_other_notes">Other Notes</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_logging">Logging and Progress Printing</a></li>
<li class="level1"><a href="#sec_supported_type_list">Supported Type List</a></li>
<li class="level1"><a href="#sec_advanced_topics">Advanced Topics</a><ul><li class="level2"><a href="#sec_functional_arguments">Functional Arguments</a><ul><li class="level3"><a href="#sec_functional_serialization">Serializing a Function</a></li>
</ul>
</li>
<li class="level2"><a href="#sec_variant_type">Variant Type</a></li>
<li class="level2"><a href="#sec_performance_notes">Performance Considerations</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The GraphLab Extension Interface was initially developed as a way to increase productivity of internal toolkit development with the objective of minimizing the friction required to expose functions and classes to Python, without requiring a ton of overhead.</p>
<p>We will describe the GraphLab Extension Interface in two parts: for <a class="el" href="page_graphlab_extension_interface.html#sec_function_extension_interface">function extensions</a>, and for <a class="el" href="page_graphlab_extension_interface.html#sec_class_extension_interface">class extensions</a>.</p>
<h1><a class="anchor" id="sec_function_extension_interface"></a>
Function Extension Interface</h1>
<p>The function extension interface provides the ability to publish functions to Python. This is easiest explained by starting with an example (See the <a class="el" href="index.html#mainpage_quickstart">Quick Start</a> for the same example below, and for compilation instructions). We will break the example down and explain each section.</p>
<p><b>C++ Extension Function</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/toolkit_function_macros.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacegraphlab.html">graphlab</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> add_integers(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">  <span class="keywordflow">return</span> a + b;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(add_integers, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>); <span class="comment">// provide named parameters</span></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --><p><b>Python Usage</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;import graphlab <span class="keyword">as</span> gl</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">import</span> example</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keywordflow">print</span> example.add_integers(5, 10)</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_function_graphlab_includes"></a>
GraphLab Includes</h2>
<p>We begin with including toolkit_function_macros.hpp This is the minimal include needed for implementing function extensions. All GraphLab objects and functions live in the <code>graphlab</code> namespace. We will use <code>using namespace graphlab;</code> here for convenience and succintness.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/toolkit_function_macros.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacegraphlab.html">graphlab</a>;</div>
</div><!-- fragment --><h2><a class="anchor" id="page_extension_interface_cpp_fn_impl"></a>
Function Implementation</h2>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> add_integers(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">  <span class="keywordflow">return</span> a + b;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The user defined function can be any function with any number of arguments. This simple example function takes two integers and returns one integer, but a large number of types are supported and are automatically translated between Python and C++. See <a class="el" href="page_graphlab_extension_interface.html#sec_supported_type_list">Supported Type List</a> for a complete list of all supported types.</p>
<h3><a class="anchor" id="sec_function_exceptions"></a>
Exceptions</h3>
<p>In the event of an error, raising a string or a const char* exception will propagate the exception back to Python as a ToolkitError. For instance:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> divide_integers(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">  <span class="keywordflow">if</span> (b == 0) {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="stringliteral">&quot;Divide by zero Error&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> a / b;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="sec_supported_type_list_examples"></a>
Examples</h3>
<p>The flexibility in the supported types allow for interesting functions to be built and exposed to Python easily. For instance:</p>
<div class="fragment"><div class="line"><span class="comment">// given a map of string keys to string values, and an list of keys</span></div>
<div class="line"><span class="comment">// Returns a list of the matching values, and an empty string for missing keys.</span></div>
<div class="line">std::vector&lt;std::string&gt; get_values(</div>
<div class="line">    <span class="keyword">const</span> std::map&lt;std::string, std::string&gt;&amp; dict, </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; keys) {</div>
<div class="line">  std::vector&lt;std::string&gt; values;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> key: keys) {</div>
<div class="line">    <span class="keyword">auto</span> iter = dict.find(key);</div>
<div class="line">    <span class="keywordflow">if</span> (iter != dict.end()) values.push_back(iter-&gt;second);</div>
<div class="line">    <span class="keywordflow">else</span> values.push_back(std::string());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> values;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Once published (see <a class="el" href="page_graphlab_extension_interface.html#sec_function_publishing">Publishing Functions</a>), this can be called from Python with: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;values = example.get_values({<span class="stringliteral">&#39;a&#39;</span>:<span class="stringliteral">&#39;b&#39;</span>,<span class="stringliteral">&#39;c&#39;</span>:<span class="stringliteral">&#39;d&#39;</span>}, [<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;z&#39;</span>])</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keywordflow">print</span> values <span class="comment"># print [&#39;b&#39;,&#39;d&#39;,&#39;&#39;]</span></div>
</div><!-- fragment --><p> If you provide input that cannot be type converted correctly for instance:: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;values = example.get_values({<span class="stringliteral">&#39;a&#39;</span>:<span class="stringliteral">&#39;b&#39;</span>,<span class="stringliteral">&#39;c&#39;</span>:1}, [<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;z&#39;</span>])</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"># raises ToolkitError: Expecting string. But we got a integer</span></div>
</div><!-- fragment --><p>We can generalize this to support most Python built-in types by using the <a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a> instead: </p><div class="fragment"><div class="line"><span class="comment">// given a map of keys to values, and an list of keys</span></div>
<div class="line"><span class="comment">// Returns a list of the matching values, and None for missing keys.</span></div>
<div class="line">std::vector&lt;flexible_type&gt; get_values(</div>
<div class="line">    <span class="keyword">const</span> std::map&lt;flexible_type, flexible_type&gt;&amp; dict, </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;flexible_type&gt;&amp; keys) {</div>
<div class="line">  std::vector&lt;flexible_type&gt; values;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> key: keys) {</div>
<div class="line">    <span class="keyword">auto</span> iter = dict.find(key);</div>
<div class="line">    <span class="keywordflow">if</span> (iter != dict.end()) values.push_back(iter-&gt;second);</div>
<div class="line">    <span class="keywordflow">else</span> values.push_back(<a class="code" href="group__group__gl__flexible__type.html#ga6654fa4b4c00276e9491850b3cf7d90d">FLEX_UNDEFINED</a>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> values;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;values = example.get_values({<span class="stringliteral">&#39;a&#39;</span>:<span class="stringliteral">&#39;b&#39;</span>,<span class="stringliteral">&#39;c&#39;</span>:1}, [<span class="stringliteral">&#39;a&#39;</span>, <span class="stringliteral">&#39;c&#39;</span>, <span class="stringliteral">&#39;z&#39;</span>])</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keywordflow">print</span> values <span class="comment"># prints [&#39;b&#39;, 1, None]</span></div>
</div><!-- fragment --><h2><a class="anchor" id="sec_function_publishing"></a>
Publishing Functions</h2>
<p>To publish functions, simply add the <a class="el" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a> and <a class="el" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a> macro pair <em>outside of all namespace scopes</em>. This macro simply introduces a function called "get_toolkit_function_registration()" which GraphLab Create can call and query at runtime. </p><div class="fragment"><div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(add, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>); <span class="comment">// provide named parameters</span></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(get_values, <span class="stringliteral">&quot;dictionary&quot;</span>, <span class="stringliteral">&quot;keys&quot;</span>); </div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You should only have one occurance of these macros in an entire library. i.e. if you compile an extension "example.so" out of 3 cpp files, a.cpp, b.cpp and c.cpp; even though you may have extension functions in all 3 cpp files, you must only perform registration for all extension functions in one of the cpp files.</dd></dl>
<p>Between <a class="el" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a> and <a class="el" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a> macros, you can use the other function registration macros in <a class="el" href="group__group__gl__ffi.html">GraphLab Extension Interface</a>. For instance, <code>"REGISTER_FUNCTION(add_integers, "a", "b")"</code> will register the "add_integers" function with 2 arguments, naming the first argument "a" and the 2nd argument "b". This allows the function to be called from Python with</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example.add_integers(5,10)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">#or</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;example.add_integers(a=5, b=10)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Be careful not to use Python reserved names as named arguments. That will cause interesting issues.</dd></dl>
<p><a class="el" href="group__group__gl__function__ffi.html#gafdaa7f30a7425a7b6a904efe782a0cb6">REGISTER_NAMED_FUNCTION</a> can also be used if the name of the C++ function should not be the same as the name of the Python function published. <a class="el" href="group__group__gl__function__ffi.html#gaf476a39341a191c739319ecca72919db">REGISTER_DOCSTRING</a> can be used to associate a docstring with the function.</p>
<h2><a class="anchor" id="sec_function_compilation"></a>
Compilation</h2>
<p>That's it! To compile see the <a class="el" href="index.html#mainpage_quickstart">Quick Start</a> for compilation instructions.</p>
<h2><a class="anchor" id="sec_function_python_import"></a>
Python Import</h2>
<p>There are two modes of importing a GraphLab Create extension from Python. The first is easier to use, while the second is easier to diagnose issues and is more powerful.</p>
<h3><a class="anchor" id="sec_function_python_import_hook"></a>
Import Hook</h3>
<p>The first method is based on <a href="http://legacy.python.org/dev/peps/pep-0302/">Python import hooks</a>. When GraphLab Create is imported, via: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> graphlab</div>
</div><!-- fragment --><p> GraphLab Create injects an import hook to capture all subsequent imports and automatically load what might be extensions.</p>
<p>Therefore once GraphLab is imported, and a compiled extension (ex: example.so), is in the current working directory (Or in the PYTHONPATH), the following import will work: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> example</div>
</div><!-- fragment --><p> And your functions will be immediately accessible via example.[fn]</p>
<p>Simultaneously, all loaded extensions can be accessed in the <code>graphlab.extensions</code> namespace. For instance: <code>graphlab.extensions.example</code>.[fn]</p>
<h3><a class="anchor" id="sec_function_python_ext_import"></a>
ext_import</h3>
<p>The second method is to use the ext_import function in gl.extensions. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> graphlab</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;graphlab.ext_import(<span class="stringliteral">&quot;filename.so&quot;</span>)</div>
</div><!-- fragment --><p> With this method of importing, the loaded extension is only accessible via <code>graphlab.extensions.example</code>.[fn]. However, the so-file is allowed to reside on any filesystem GraphLab Create can read natively: i.e. http, hdfs, etc.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;graphlab.ext_import(<span class="stringliteral">&quot;hdfs://somewhere/outthere/example1.so&quot;</span>)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;graphlab.ext_import(<span class="stringliteral">&quot;http://somewhereelse/example2.so&quot;</span>)</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_class_extension_interface"></a>
Class Extension Interface</h1>
<p>The class extension provides the ability to publish c++ classes to Python. Once again, we begin with an example.</p>
<p>This is a simple class which contains three settable string properties and has a function which returns the concatenation of all of them. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/toolkit_class_macros.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacegraphlab.html">graphlab</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>demo_class: <span class="keyword">public</span> toolkit_class_base {</div>
<div class="line"> std::string one;</div>
<div class="line"> std::string two;</div>
<div class="line"> std::string three;</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  std::string concat() {</div>
<div class="line">    <span class="keywordflow">return</span> one + two + three;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> set_one(<span class="keyword">const</span> std::string&amp; one_value) {</div>
<div class="line">    one = one_value;</div>
<div class="line">  }</div>
<div class="line">  std::string get_one() {</div>
<div class="line">    <span class="keywordflow">return</span> one;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> set_two(<span class="keyword">const</span> std::string&amp; two_value) {</div>
<div class="line">    two = two_value;</div>
<div class="line">  }</div>
<div class="line">  std::string get_two() {</div>
<div class="line">    <span class="keywordflow">return</span> two;</div>
<div class="line">  }</div>
<div class="line"> <a class="code" href="group__group__gl__class__ffi.html#ga676bb5a6917bd1d9f92a4fa2c40cc16e">BEGIN_CLASS_MEMBER_REGISTRATION</a>(<span class="stringliteral">&quot;demo_class&quot;</span>)</div>
<div class="line"> <a class="code" href="group__group__gl__class__ffi.html#gabe40942a56db9a1d1cf2594c41a944f2">REGISTER_CLASS_MEMBER_FUNCTION</a>(demo_class::concat)</div>
<div class="line"> <a class="code" href="group__group__gl__class__ffi.html#gabe40942a56db9a1d1cf2594c41a944f2">REGISTER_CLASS_MEMBER_FUNCTION</a>(demo_class::set_one, &quot;one_value&quot;)</div>
<div class="line"> <a class="code" href="group__group__gl__class__ffi.html#gabe40942a56db9a1d1cf2594c41a944f2">REGISTER_CLASS_MEMBER_FUNCTION</a>(demo_class::get_one)</div>
<div class="line"> <a class="code" href="group__group__gl__class__ffi.html#ga45a0e57a8417e3e15f5efddfd60fd5dc">REGISTER_GETTER</a>(&quot;two&quot;, demo_class::get_two)</div>
<div class="line"> <a class="code" href="group__group__gl__class__ffi.html#ga7348d79446e17ea4a88e0943ee50d0eb">REGISTER_SETTER</a>(&quot;two&quot;, demo_class::set_two)</div>
<div class="line"> <a class="code" href="group__group__gl__class__ffi.html#gae15bebdc7113edfe282423da61b15343">REGISTER_PROPERTY</a>(three)</div>
<div class="line"> <a class="code" href="group__group__gl__class__ffi.html#ga4b098f252334dce87dbdfc86b345bb81">END_CLASS_MEMBER_REGISTRATION</a></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#gaf9215244d8e23138c317d7facd46ab96">BEGIN_CLASS_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga5eb7b0a8a124d9ea93bc29614d3b7998">REGISTER_CLASS</a>(demo_class)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga42cd1277ab45409c98e1e8ba22aae5e5">END_CLASS_REGISTRATION</a></div>
</div><!-- fragment --><p><b>Python Usage</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> graphlab <span class="keyword">as</span> gl</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">import</span> example</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;g = example.demo_class()</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;g.set_one(<span class="stringliteral">&quot;hello&quot;</span>)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;g.two = <span class="stringliteral">&quot; &quot;</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;g.three = <span class="stringliteral">&quot;world!&quot;</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keywordflow">print</span> g.concat() <span class="comment"># prints &quot;hello world!&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="sec_class_graphlab_includes"></a>
GraphLab Includes</h2>
<p>We begin with including graphlab/sdk/toolkit_class_macros.hpp. This is the minimal include needed for implementing class extensions. All GraphLab objects and functions live in the <code>graphlab</code> namespace. We will use <code>using namespace graphlab;</code> here for convenience and succintness.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/toolkit_class_macros.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacegraphlab.html">graphlab</a>;</div>
</div><!-- fragment --><h2><a class="anchor" id="page_extension_interface_cpp_class_impl"></a>
Class Implementation</h2>
<p>The class <b>must</b> inherit from graphlab::toolkit_class_base which provides the support for the within-class function dispatch.</p>
<p>The rest of the class is mostly implementation. In this case we implement getters and setters for the "one" and "two" private members, as well as the main concat() function.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>demo_class: <span class="keyword">public</span> toolkit_class_base {</div>
<div class="line"> std::string one;</div>
<div class="line"> std::string two;</div>
<div class="line"> std::string three;</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  std::string concat() {</div>
<div class="line">    <span class="keywordflow">return</span> one + two + three;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> set_one(<span class="keyword">const</span> std::string&amp; one_value) {</div>
<div class="line">    one = one_value;</div>
<div class="line">  }</div>
<div class="line">  std::string get_one() {</div>
<div class="line">    <span class="keywordflow">return</span> one;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> set_two(<span class="keyword">const</span> std::string&amp; two_value) {</div>
<div class="line">    two = two_value;</div>
<div class="line">  }</div>
<div class="line">  std::string get_two() {</div>
<div class="line">    <span class="keywordflow">return</span> two;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The class <b>must</b> have a default constructor, copy constructor and assignment operator. In this case we are just using the default ones generated by C++.</p>
<p>The functions can be any function with any number of arguments and a large number of types are supported and are automatically translated between Python and C++. See <a class="el" href="page_graphlab_extension_interface.html#sec_supported_type_list">Supported Type List</a> for a complete list of all supported types.</p>
<p>Additionally, functions (all extension functions and published functions of extension classes) can take instances of demo_class. For instance, I could publish a function:</p>
<div class="fragment"><div class="line">std::string run_concat(demo_class c) {</div>
<div class="line">  <span class="keywordflow">return</span> c.concat();</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(run_concat, <span class="stringliteral">&quot;c&quot;</span>); </div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;c = example.demo_class()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;c.set_one(<span class="stringliteral">&quot;hello&quot;</span>)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;ret = example.run_concat(c)</div>
</div><!-- fragment --><p>To take an instance of a class <em>by reference</em>, I take a shared_ptr to it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_one(std::shared_ptr&lt;demo_class&gt; c) {</div>
<div class="line">  c-&gt;set_one(<span class="stringliteral">&quot;one&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(set_one, <span class="stringliteral">&quot;c&quot;</span>); </div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;c = example.demo_class()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;example.set_one(c)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;one = c.get_one() <span class="comment"># returns &quot;one&quot;</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>To take an instance by reference, shared_ptr&lt;...&gt; is necessary. Simply passing by reference i.e. <code> demo_class&amp; </code> will not work.</dd>
<dd>
Functions can also return toolkit class instances. You can return either the toolkit class, or a shared_ptr&lt;...&gt; to the toolkit class. The latter is prefered.</dd></dl>
<h3><a class="anchor" id="sec_class_exceptions"></a>
Exceptions</h3>
<p>Just like with functions, in the event of an error, raising a string or a const char* exception will propagate the exception back to Python as a RuntimeError.</p>
<h2><a class="anchor" id="sec_class_publishing"></a>
Publishing Classes</h2>
<p>Classes require two registration operations. Once to register the class members within the class. And the second time to register the existance of the class itself.</p>
<h3><a class="anchor" id="sec_class_member_publishing"></a>
Class Member Registration</h3>
<p>Class member registration is done by placing the BEGIN_CLASS_MEMBER_REGISTRATION and END_CLASS_MEMBER_REGISTRATION pair inside the class definition. (If you have a header / cpp split. this must be done in the header inside the class definition)</p>
<div class="fragment"><div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga676bb5a6917bd1d9f92a4fa2c40cc16e">BEGIN_CLASS_MEMBER_REGISTRATION</a>(<span class="stringliteral">&quot;demo_class&quot;</span>)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#gabe40942a56db9a1d1cf2594c41a944f2">REGISTER_CLASS_MEMBER_FUNCTION</a>(demo_class::concat)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#gabe40942a56db9a1d1cf2594c41a944f2">REGISTER_CLASS_MEMBER_FUNCTION</a>(demo_class::set_one, &quot;one_value&quot;)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#gabe40942a56db9a1d1cf2594c41a944f2">REGISTER_CLASS_MEMBER_FUNCTION</a>(demo_class::get_one)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga45a0e57a8417e3e15f5efddfd60fd5dc">REGISTER_GETTER</a>(&quot;two&quot;, demo_class::get_two)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga7348d79446e17ea4a88e0943ee50d0eb">REGISTER_SETTER</a>(&quot;two&quot;, demo_class::set_two)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#gae15bebdc7113edfe282423da61b15343">REGISTER_PROPERTY</a>(three)</div>
<div class="line">END_CLASS_MEMBER_REGISTRATION</div>
</div><!-- fragment --><p><a class="el" href="group__group__gl__class__ffi.html#ga676bb5a6917bd1d9f92a4fa2c40cc16e">BEGIN_CLASS_MEMBER_REGISTRATION</a> takes an argument which is the python facing name of the class. Between <a class="el" href="group__group__gl__class__ffi.html#ga676bb5a6917bd1d9f92a4fa2c40cc16e">BEGIN_CLASS_MEMBER_REGISTRATION</a> and <a class="el" href="group__group__gl__class__ffi.html#ga4b098f252334dce87dbdfc86b345bb81">END_CLASS_MEMBER_REGISTRATION</a> you can use the other class member registration macros in <a class="el" href="group__group__gl__ffi.html">GraphLab Extension Interface</a>. <a class="el" href="group__group__gl__class__ffi.html#gabe40942a56db9a1d1cf2594c41a944f2">REGISTER_CLASS_MEMBER_FUNCTION</a> behaves like <a class="el" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a> and <a class="el" href="group__group__gl__class__ffi.html#ga36b333bc3975f18e620dec87e601aeb3">REGISTER_NAMED_CLASS_MEMBER_FUNCTION</a> behaves like <a class="el" href="group__group__gl__function__ffi.html#gafdaa7f30a7425a7b6a904efe782a0cb6">REGISTER_NAMED_FUNCTION</a>. In addition for classes there are three additional macros used to support properties.</p>
<p>A "getter-setter" pair can be defined for a Python property (called "two") </p><div class="fragment"><div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga45a0e57a8417e3e15f5efddfd60fd5dc">REGISTER_GETTER</a>(<span class="stringliteral">&quot;two&quot;</span>, demo_class::get_two)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga7348d79446e17ea4a88e0943ee50d0eb">REGISTER_SETTER</a>(&quot;two&quot;, demo_class::set_two)</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;g = extensions.demo_class()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;g.two = <span class="stringliteral">&quot;hello&quot;</span> <span class="comment"># calls the setter for the property &quot;two&quot;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;t = g.two  <span class="comment"># calls the getter for the property &quot;two&quot;</span></div>
</div><!-- fragment --><p>Or, <a class="el" href="group__group__gl__class__ffi.html#gae15bebdc7113edfe282423da61b15343">REGISTER_PROPERTY</a> can be used automatically generate a default getter/setter pair which just exposes a member variable as a public facing property.</p>
<h3><a class="anchor" id="sec_class_publishing"></a>
Publishing Classes</h3>
<p>Finally, the class itself must be registered. To publish class , simply add the <a class="el" href="group__group__gl__class__ffi.html#gaf9215244d8e23138c317d7facd46ab96">BEGIN_CLASS_REGISTRATION</a> and <a class="el" href="group__group__gl__class__ffi.html#ga42cd1277ab45409c98e1e8ba22aae5e5">END_CLASS_REGISTRATION</a> macro pair <em>outside of all namespace scopes</em>. This macro simply introduces a function called "get_toolkit_class_registration()" which GraphLab Create can call and query at runtime. </p><div class="fragment"><div class="line"><a class="code" href="group__group__gl__class__ffi.html#gaf9215244d8e23138c317d7facd46ab96">BEGIN_CLASS_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga5eb7b0a8a124d9ea93bc29614d3b7998">REGISTER_CLASS</a>(demo_class)</div>
<div class="line"><a class="code" href="group__group__gl__class__ffi.html#ga42cd1277ab45409c98e1e8ba22aae5e5">END_CLASS_REGISTRATION</a></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You should only have one occurance of these macros in an entire library. i.e. if you compile an extension "example.so" out of 3 cpp files, a.cpp, b.cpp and c.cpp; even though you may have extension classes in all 3 cpp files, you must only perform registration for all extension classes in one of the cpp files. You can have both class registration AND function registration in the same so.</dd></dl>
<h2><a class="anchor" id="sec_class_compilation"></a>
Compilation And Python Import</h2>
<p>That's it! To compile see the <a class="el" href="index.html#mainpage_quickstart">Quick Start</a> for compilation instructions. Usage is same as functions in <a class="el" href="page_graphlab_extension_interface.html#sec_function_python_import">Python Import</a>.</p>
<h2><a class="anchor" id="sec_class_other_notes"></a>
Other Notes</h2>
<p>The Python publishing mechanism has due to Python's simple object model, has interesting capabilities. For instance, publishing a <code> std::string __str__() </code> and an <code> std::string __repr__() </code> function will allow for nice automatic printing when running Python interactively (for instance in a REPL environment like IPython).</p>
<h1><a class="anchor" id="sec_logging"></a>
Logging and Progress Printing</h1>
<p>You can use <code> logprogress_stream </code> for printing progress, or log message to the python client.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="comment">// \file example.cpp</span></div>
<div class="line"><span class="comment">// Compiled as example.so</span></div>
<div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/toolkit_function_macros.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacegraphlab.html">graphlab</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> add_integers(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">  logprogress_stream  &lt;&lt; <span class="stringliteral">&quot;Debug: &quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> a + b;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(add_integers, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>); <span class="comment">// provide named parameters</span></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --><p><b>In Python</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&gt;&gt;&gt; <span class="keyword">import</span> graphlab <span class="keyword">as</span> gl</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;&gt;&gt;&gt; <span class="keyword">import</span> example</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;&gt;&gt;&gt; example.add_integers(5, 10)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;PROGRESS: Debug: 5 + 10 =</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;15</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For simplicity, we use std::cout throughout the documentation to illustrate the output of code snippets. However, stdout or stderr are not displayed in python.</dd></dl>
<h1><a class="anchor" id="sec_supported_type_list"></a>
Supported Type List</h1>
<p>This is a list of the currently supported types which are automatically translated between Python and C++. There are a number of recursive cases (for instance lists of arbitrary values), in which case the types "S" and "T" will be used as placeholders.</p>
<p><b>Supported From <a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a></b></p>
<table class="doxtable">
<tr>
<td><b>C++ Type</b> </td><td><b>Accepts Python Type</b> </td><td><p class="starttd"><b>Returns Python Type</b> </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Any integral value (int, long, size_t, <a class="el" href="group__group__flexible__type__types.html#gacb1b9af01944bff1801e2f3c2d821291">flex_int</a>, etc) </td><td>Any numeric value </td><td><p class="starttd">int </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Any floating point value (float, double, <a class="el" href="group__group__flexible__type__types.html#ga9974c59a3a117b27a579ad353ffbee19">flex_float</a>) </td><td>Any numeric value </td><td><p class="starttd">float </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::string / <a class="el" href="group__group__flexible__type__types.html#gafee487bb0098ddd88c6fa4f18c0ac8eb">flex_string</a> </td><td>string </td><td><p class="starttd">string </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a class="el" href="structgraphlab_1_1flex__date__time.html">flex_date_time</a> </td><td>datetime.datetime </td><td><p class="starttd">datetime.datetime </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>flex_image </td><td>graphlab.Image </td><td><p class="starttd">graphlab.Image </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::vector&lt;double&gt; / <a class="el" href="group__group__flexible__type__types.html#ga36102d38d9f710205277a2852abc87d1">flex_vec</a> </td><td>Any list, tuple, array of numeric values. </td><td><p class="starttd">array.array </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::vector&lt;flexible_type&gt; / <a class="el" href="group__group__flexible__type__types.html#gaa8f7213ab9192f0a5318b6c5c47d43ab">flex_list</a> </td><td>Any list, tuple, array of numeric values. </td><td><p class="starttd">array.array </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::vector&lt;std::pair&lt;flexible_type, flexible_type&gt; &gt; / <a class="el" href="group__group__flexible__type__types.html#ga4e7fd5b76d8f6400c2f019283b62d33b">flex_dict</a> </td><td>dict </td><td><p class="starttd">dict </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a> </td><td>variable at runtime. </td><td>variable at runtime.  </td></tr>
</table>
<p><b> GraphLab Datastructures </b> </p><table class="doxtable">
<tr>
<td><b>C++ Type</b> </td><td><b>Accepts Python Type</b> </td><td><p class="starttd"><b>Returns Python Type</b> </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> </td><td>SArray </td><td><p class="starttd">SArray </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> </td><td>SFrame </td><td><p class="starttd">SFrame </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a class="el" href="classgraphlab_1_1gl__sgraph.html">gl_sgraph</a> </td><td>SGraph </td><td>SGraph  </td></tr>
</table>
<p><b>Recursive Cases</b> </p><table class="doxtable">
<tr>
<td><b>C++ Type</b> </td><td><b>Accepts Python Type</b> </td><td><p class="starttd"><b>Returns Python Type</b> </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::pair&lt;S, T&gt; </td><td>Any list, tuple, array of 2 elements where the first is convertible to S and the 2nd is convertible to T. </td><td><p class="starttd">list of 2 elements </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::tuple&lt;T1, T2, ..., Tn&gt; </td><td>Any list, tuple, array of n elements where the first is convertible to T1 and the 2nd is convertible to T2 ... etc. </td><td><p class="starttd">list of n elements </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::map&lt;S, T&gt; </td><td>Any dictionary where the keys are convertible to S, and the values are convertible to T. </td><td><p class="starttd">dict </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::unordered_map&lt;S, T&gt; </td><td>Any dictionary where the keys are convertible to S, and the values are convertible to T. </td><td>dict  </td></tr>
</table>
<p><b>Special Types</b> </p><table class="doxtable">
<tr>
<td><b>C++ Type</b> </td><td><b>Accepts Python Type</b> </td><td><p class="starttd"><b>Returns Python Type</b> </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Descendent of toolkit_class_base </td><td>Extension class instance </td><td><p class="starttd">Extension class instance </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::shared_ptr&lt;T&gt; where T is a descendent of toolkit_class_base </td><td>Extension class instance </td><td><p class="starttd">Extension class instance </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>std::function&lt;S(T...)&gt; </td><td>See <a class="el" href="page_graphlab_extension_interface.html#sec_functional_arguments">Functional Arguments</a> </td><td><p class="starttd">See <a class="el" href="page_graphlab_extension_interface.html#sec_functional_arguments">Functional Arguments</a> </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>graphlab::variant </td><td>See <a class="el" href="page_graphlab_extension_interface.html#sec_variant_type">Variant Type</a> </td><td>See <a class="el" href="page_graphlab_extension_interface.html#sec_variant_type">Variant Type</a>  </td></tr>
</table>
<h1><a class="anchor" id="sec_advanced_topics"></a>
Advanced Topics</h1>
<h2><a class="anchor" id="sec_functional_arguments"></a>
Functional Arguments</h2>
<p>Something special that we support is the passing of functions. For instance, we can define an apply() function that takes a function as an input, and an argument, and applies the function to the argument returning the result. </p><div class="fragment"><div class="line">std::string demo_to_string(flexible_type param1) {</div>
<div class="line">  <span class="keywordflow">return</span> std::string(param1);</div>
<div class="line">}</div>
<div class="line">std::string apply(std::function&lt;std::string(<span class="keywordtype">double</span>)&gt; fn, <span class="keywordtype">double</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> fn(x);</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(demo_to_string, <span class="stringliteral">&quot;param1&quot;</span>)</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(apply, &quot;fn&quot;, &quot;argument&quot;) </div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --><p>We can use it this way: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> graphlab <span class="keyword">as</span> gl</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">import</span> example</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;example.apply(example.demo_to_string, 5) <span class="comment"># return &quot;5&quot;</span></div>
</div><!-- fragment --><p>There are significant restrictions on the passing of functions. The function must be either:</p><ul>
<li>A native function.</li>
<li>A simple lambda of a native function: i.e. the lambda must simply return a single call to a native function, where each parameter of the native function call is either be a lambda function argument, or an expression which can be evaluated immediately within the scope.</li>
</ul>
<p>Lets detail the 2nd case with examples. Consider the following extension functions. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> add(<span class="keywordtype">double</span> param1, <span class="keywordtype">double</span> param2) {</div>
<div class="line">  <span class="keywordflow">return</span> param1 + param2;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">double</span> apply(std::function&lt;<span class="keywordtype">double</span>(<span class="keywordtype">double</span>)&gt; fn, <span class="keywordtype">double</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> fn(x);</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(add, <span class="stringliteral">&quot;param1&quot;</span>, <span class="stringliteral">&quot;param2&quot;</span>) </div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(apply, &quot;fn&quot;, &quot;argument&quot;) </div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --><p>All the following are valid: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example.apply(<span class="keyword">lambda</span> x: example.add(x, 5), 10) <span class="comment"># return 15</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;t = 5</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;y = 2</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;example.apply(<span class="keyword">lambda</span> x: example.add(x, t), 10) <span class="comment"># return 15</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;example.apply(<span class="keyword">lambda</span> x: example.add(x, t+2*y), 10) <span class="comment"># return 19</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;example.apply(<span class="keyword">lambda</span> x: example.add(t*t, t+2*y), 10) <span class="comment"># return 34</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;example.apply(<span class="keyword">lambda</span> x: example.add(x, x), 10) <span class="comment"># return 20</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">def </span>fn(x):</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  <span class="keywordflow">return</span> example.add(x, t)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;example.apply(fn, 10) <span class="comment"># return 15</span></div>
</div><!-- fragment --><p>All the following are invalid: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example.apply(<span class="keyword">lambda</span> x: example.add(x+1, 5), 10) <span class="comment"># FAIL: x+1 is an expression using lambda arguments</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;t = 5</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;example.apply(<span class="keyword">lambda</span> x: example.add(x+t, t), 10) <span class="comment"># FAIL: x+t is an expression using lambda arguments</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;example.apply(<span class="keyword">lambda</span> x: 1 + example.add(x, 5), 10) <span class="comment"># FAIL: lambda does not comprise of a simple function call</span></div>
</div><!-- fragment --><h3><a class="anchor" id="sec_functional_serialization"></a>
Serializing a Function</h3>
<p>In some cases (for instance in a toolkit class), it might be desirable to actually "save" the function. (For instance a user defined distance function). The std::function, while convenient, makes saving impossible. To allow for the saving and loading of functions, we must go one level down, and instead capture a <a class="el" href="structgraphlab_1_1function__closure__info.html">function_closure_info</a> object.</p>
<p>For instance, repeating the above "apply" example: </p><div class="fragment"><div class="line">std::string apply_functional_form(std::function&lt;std::string(<span class="keywordtype">double</span>)&gt; fn, <span class="keywordtype">double</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> fn(x);</div>
<div class="line">}</div>
<div class="line">std::string apply_closure_capture_form(function_closure_info fn, <span class="keywordtype">double</span> x) {</div>
<div class="line">  <span class="comment">// now, fn is serializable and can be saved / loaded.</span></div>
<div class="line">  <span class="comment">// however, calling the function requires a little work.</span></div>
<div class="line">  <span class="keyword">auto</span> actual_fn = variant_get_value&lt; std::function&lt;std::string(double)&gt; &gt;(fn);</div>
<div class="line">  actual_fn(x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, there are certain limitations of the <a class="el" href="structgraphlab_1_1function__closure__info.html">function_closure_info</a>. It only saves a reference to the function, and not the function itself. i.e. If the user provides a function from an extension, then the extension must also be loaded for the function to be used. For instance:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> graphlab <span class="keyword">as</span> gl</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">import</span> my_extension</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"># create a model using my_function in my_extension as the distance function</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;model = gl.nearest_neighbor.create(... my_extension.my_function ...)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;model.save(<span class="stringliteral">&#39;test.model&#39;</span>)</div>
</div><!-- fragment --><p>Then this will fail. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> graphlab <span class="keyword">as</span> gl</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;model = gl.load_model(<span class="stringliteral">&#39;test.model&#39;</span>)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;model.predict(...) <span class="comment"># because my_extension.my_function is not available.</span></div>
</div><!-- fragment --><p>However this will succeed: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> graphlab <span class="keyword">as</span> gl</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;model = gl.load_model(<span class="stringliteral">&#39;test.model&#39;</span>)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">import</span> my_extension</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;model.predict(...)</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_variant_type"></a>
Variant Type</h2>
<p>The <a class="el" href="namespacegraphlab.html#a7c637ac1b6f04b667778430dad94dc06">variant_type</a> is the primary internal type used for communicating information to and from Python: whether it is an integer, a dictionary, or an SArray. Thus an extension function which accepts, or returns a variant_type is in a way the most general. The variant_type should not accessed directly, but can be converted to and from arbitrary types using the <a class="el" href="namespacegraphlab.html#a8137978d2509b03640aeca9a9d24e50e">to_variant</a> and <a class="el" href="namespacegraphlab.html#ae1e748a7e3dc50f3a1a6af57012b200a">variant_get_value</a> functions.</p>
<p>For instance, if I am to implement a function that when given a Python list, if the list is all numbers, returns the sum. And if the list is all strings, return the concatenation. I might implement the following: </p><div class="fragment"><div class="line"><a class="code" href="namespacegraphlab.html#a7c637ac1b6f04b667778430dad94dc06">variant_type</a> add_list(<span class="keyword">const</span> <a class="code" href="namespacegraphlab.html#a7c637ac1b6f04b667778430dad94dc06">variant_type</a>&amp; v) {</div>
<div class="line">  std::vector&lt;double&gt; numeric_list;</div>
<div class="line">  std::vector&lt;std::string&gt; string_list;</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    numeric_list = variant_get_value&lt;std::vector&lt;double&gt; &gt;(v);</div>
<div class="line">    <span class="keywordtype">double</span> ret = 0;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i: numeric_list) ret += i;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacegraphlab.html#a8137978d2509b03640aeca9a9d24e50e">to_variant</a>(ret);</div>
<div class="line">  } <span class="keywordflow">catch</span>(...) {</div>
<div class="line">    <span class="comment">// will throw a string exception on failure.</span></div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// try the string conversion</span></div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    string_list = variant_get_value&lt;std::vector&lt;std::string&gt; &gt;(v);</div>
<div class="line">    std::string ret;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i: string_list) ret += i;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacegraphlab.html#a8137978d2509b03640aeca9a9d24e50e">to_variant</a>(ret);</div>
<div class="line">  } <span class="keywordflow">catch</span>(...) {</div>
<div class="line">    <span class="comment">// will throw a string exception on failure.</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">throw</span> <span class="stringliteral">&quot;Invalid list type.&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_performance_notes"></a>
Performance Considerations</h2>
<p><b> Call Throughput </b></p>
<p>Each toolkit function / class call does incur a decent amount of overhead (it requires serialization to C++, communicating it across an interprocess boundary, writes to a log file, etc). The toolkit function /class interface is designed to provide relatively infrequent large calls and not very fine-grained calls. It should have a call throughput of a few thousand calls per second.</p>
<p><b> Functions which take extension classes as input arguments</b></p>
<p>Functions which take extension classes, for instance: </p><div class="fragment"><div class="line">std::string run_concat(<span class="keyword">const</span> demo_class&amp; c) {</div>
<div class="line">  <span class="keywordflow">return</span> c.concat();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Even if it is passed by reference to the function, will incur the cost of a copy of the class instance. If the class is lightweight, this is not a problem. But using the shared_ptr is prefered since this avoids the copy </p><div class="fragment"><div class="line">std::string run_concat(std::shared_ptr&lt;demo_class&gt; c) {</div>
<div class="line">  <span class="keywordflow">return</span> c.concat();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similarly, for functions which return new classes, it is prefered that it returns a shared_ptr to the class rather than the class itself. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 10 2014 14:35:58 for GraphLab Create SDK API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
