<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GraphLab Create SDK API: SFrame User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab Create SDK API
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_userguide_sframe.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SFrame User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_sarray_intro">SArray</a><ul><li class="level2"><a href="#sec_sarray_construction">Constructing SArray</a></li>
<li class="level2"><a href="#sec_sarray_writer">SArray Writer Interface</a></li>
<li class="level2"><a href="#sec_sarray_operation">Operators</a></li>
<li class="level2"><a href="#sec_sarray_iterator">SArray Iterator</a></li>
<li class="level2"><a href="#sec_sarray_apply">Apply User Defined Function</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_sframe_intro">SFrame</a><ul><li class="level2"><a href="#sec_sframe_usage">Using SFrame</a></li>
<li class="level2"><a href="#sec_sframe_construction">Constructing SFrame</a></li>
<li class="level2"><a href="#sec_sframe_writer">SFrame Writer Interface</a></li>
<li class="level2"><a href="#sec_sframe_apply">Apply User Defined Function</a></li>
<li class="level2"><a href="#sec_sframe_groupby_aggregate">Groupby Aggregate</a><ul><li class="level3"><a href="#sec_sframe_customized_groupby">User Defined Groupby Aggregator</a></li>
</ul>
</li>
<li class="level2"><a href="#sec_sframe_reshape">Stack and Unstack (also known as reshape or pivot)</a></li>
<li class="level2"><a href="#sec_sframe_python_binding">Python Binding</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_detail">Details</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="sec_sarray_intro"></a>
SArray</h1>
<p>SArray (<a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a>) is an immutable, homogeneously typed array object backed by persistent storage. It is the building block of scalable data structures in <b>GraphLab Create</b>.</p>
<p>The <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> is a contiguous column of a single type with missing value support, and works with disk to support the holding of data that is much larger than the machine's main memory. Runtime typing of the <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> is managed through the <a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a>, which is an efficient runtime typed value. The types supported by the <a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a> are listed in <a class="el" href="group__group__gl__flexible__type.html#gaede798d6769152c1e46fd2c8983e5755">flex_type_enum</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The special type <a class="el" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755a0db45d2a4141101bdfe48e3314cfbca3">flex_type_enum::UNDEFINED</a> (or the value <a class="el" href="group__group__gl__flexible__type.html#ga6654fa4b4c00276e9491850b3cf7d90d">FLEX_UNDEFINED</a> ) is used to denote a missing value (<b>na</b> in R or <b>None</b> in Python) and can be used in combination with any types.</dd></dl>
<h2><a class="anchor" id="sec_sarray_construction"></a>
Constructing SArray</h2>
<p>SArray can be constructed from in memory std::vector&lt;flexible_type&gt; or initializer list.</p>
<p>For instance: </p><div class="fragment"><div class="line"><span class="comment">// creates an array of 5 integers</span></div>
<div class="line">gl_sarray g({1,2,3,4,5}); </div>
<div class="line"></div>
<div class="line"><span class="comment">// creates an array of 5 doubles</span></div>
<div class="line">gl_sarray g1({1.0,2.0,3.0,4.0,5.0}); </div>
<div class="line"></div>
<div class="line"><span class="comment">// creates an array of 4 doubles with one missing value</span></div>
<div class="line">gl_sarray g2({1.0,2.0,3.0,<a class="code" href="group__group__gl__flexible__type.html#ga6654fa4b4c00276e9491850b3cf7d90d">FLEX_UNDEFINED</a>,5.0}); </div>
</div><!-- fragment --><p>SArray is homogeneously typed. Although the following code will happily compile as an extension, </p><div class="fragment"><div class="line"><span class="comment">// file test.cpp, compiled into test.so</span></div>
<div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/gl_sarray.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/toolkit_function_macros.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacegraphlab.html">graphlab</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> bad_sarray() {</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a>{1,2,3, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>};</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(bad_sarray)</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
<div class="line"><span class="comment">// end of test.cpp</span></div>
</div><!-- fragment --><p>when used in python it will end up with runtime exception: </p><div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> <a class="code" href="namespacegraphlab.html">graphlab</a> as gl</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">import</span> test </div>
<div class="line">&gt;&gt;&gt; test.bad_sarray()</div>
<div class="line">ToolkitError: Cannot infer Array type. Not all elements of array are the same type.</div>
</div><!-- fragment --><p>We also provide functions to create simple SArrays.</p>
<p>For instance: </p><div class="fragment"><div class="line"><span class="comment">// creates an array of 10 string values equal to &quot;foo&quot;.</span></div>
<div class="line">gl_sarray g = <a class="code" href="classgraphlab_1_1gl__sarray.html#a9c934f63da388930599ed12ca1fb8a9f">gl_sarray::from_const</a>( <span class="stringliteral">&quot;foo&quot;</span>, 10 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// creates an array of 0 to 999.</span></div>
<div class="line">gl_sarray g1 = <a class="code" href="classgraphlab_1_1gl__sarray.html#abf90998be0008c67d73e57160bf7284a">gl_sarray::from_sequence</a>( 0, 1000 );</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_sarray_writer"></a>
SArray Writer Interface</h2>
<p>The <a class="el" href="classgraphlab_1_1gl__sarray__writer.html">gl_sarray_writer</a> provides the ability to write an <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a>, which is internally cut into a collection of segments. Each segment can be written to independently, and the resultant SArray is the effective concatenation of all the segments.</p>
<div class="fragment"><div class="line"><span class="comment">// Writes an integer SArray of 4 segments.</span></div>
<div class="line">gl_sarray_writer writer(<a class="code" href="group__group__gl__flexible__type.html#gaede798d6769152c1e46fd2c8983e5755">flex_type_enum</a>:INTEGER, 4);</div>
<div class="line"></div>
<div class="line"><span class="comment">// for each segment, write a bunch of 10 values.</span></div>
<div class="line"><span class="comment">// segment 0 has 10 0&#39;s, </span></div>
<div class="line"><span class="comment">// segment 1 has 10 1&#39;s,</span></div>
<div class="line"><span class="comment">// etc</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> seg = 0;seg &lt; 4; ++seg) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0;i &lt; 10; ++i) {</div>
<div class="line">    writer.write(i, seg);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">gl_sarray sa = writer.close();</div>
<div class="line"><span class="comment">// sa is now an SArray of 40 elements comprising of </span></div>
<div class="line"><span class="comment">// the sequence 10 0&#39;s, 10 1&#39;s, 10 2&#39;s, 10 3&#39;s</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Different segments can be written safely in parallel. </dd>
<dd>
It is not safe to write to the same segment simultanously.</dd></dl>
<h2><a class="anchor" id="sec_sarray_operation"></a>
Operators</h2>
<p>SArray supports <b>numerical operators</b>, <b>comparison operators</b>, and <b>logical operators</b> with "python-like" syntax.</p>
<p>For instance: </p><div class="fragment"><div class="line">gl_sarray a{1,2,3,4,5};</div>
<div class="line"><span class="comment">// an array of 5 exclamation marks</span></div>
<div class="line">gl_sarray b = <a class="code" href="classgraphlab_1_1gl__sarray.html#a9c934f63da388930599ed12ca1fb8a9f">gl_sarray::from_const</a>(<span class="stringliteral">&quot;!&quot;</span>, 5);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> ret = (2 * sa - 1).astype(<a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755a63b588d5559f64f89a416e656880b949">flex_type_enum::STRING</a>) + b;</div>
<div class="line"><span class="comment">// results in ret being the array [&quot;1!&quot;, &quot;3!&quot;, &quot;5!&quot;, &quot;7!&quot;, &quot;9!&quot;];</span></div>
</div><!-- fragment --><p><b>Comparison operators</b> will return a <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> of binary integers. </p><div class="fragment"><div class="line">gl_sarray a{1,2,3,4,5};</div>
<div class="line"><span class="keyword">auto</span> ret = a &gt; 3; </div>
<div class="line"><span class="comment">// ret will be an integer array containing [0,0,0,1,1]</span></div>
</div><!-- fragment --><p>Logical and bitwise operators are equivalent: &amp; and &amp;&amp; mean the same thing and | and || and provide logical element-wise "and" and "or"s.</p>
<div class="fragment"><div class="line">gl_sarray a{1,2,3,4,5};</div>
<div class="line"><span class="keyword">auto</span> ret = a &gt; 1 &amp;&amp; a &lt;= 4; </div>
<div class="line"><span class="comment">// ret will be an integer array containing [0,1,1,1,0]</span></div>
</div><!-- fragment --><p>These are useful for the <b>logical filter</b> operation: </p><div class="fragment"><div class="line">gl_sarray a{1,2,3,4,5};</div>
<div class="line">gl_sarray b = a.astype(<a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755a63b588d5559f64f89a416e656880b949">flex_type_enum::STRING</a>);</div>
<div class="line"><span class="keyword">auto</span> ret = b[a &gt; 1 &amp;&amp; a &lt;= 4]; </div>
<div class="line"><span class="comment">// ret will be an string array containing [&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span></div>
</div><!-- fragment --><p>The logical and bitwise operators can be used with non-integral arrays in which case all empty values evaluate to False. i.e. for string, list, and dictionary SArrays, empty values are interpreted as false.</p>
<p>For instance: </p><div class="fragment"><div class="line">gl_sarray a{<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>}; <span class="comment">// sarray of strings</span></div>
<div class="line">gl_sarray b{1,1,0}; <span class="comment">// sarray of integers</span></div>
<div class="line"><span class="keyword">auto</span> ret = a &amp;&amp; b; <span class="comment">// ret is now {1, 0, 0}</span></div>
</div><!-- fragment --><h2><a class="anchor" id="sec_sarray_iterator"></a>
SArray Iterator</h2>
<p>SArray supports range slicing: </p><div class="fragment"><div class="line">gl_sarray s{1,2,3,4,5};</div>
<div class="line">gl_sarray t = s[{0,3}]; </div>
<div class="line">gl_sarray u = s[{-3,-1}]; </div>
<div class="line"></div>
<div class="line"><span class="comment">// t is [1,2]</span></div>
<div class="line"><span class="comment">// u is [3,4]</span></div>
</div><!-- fragment --><p>It can be read <b>inefficiently</b> using <a class="el" href="classgraphlab_1_1gl__sarray.html#a2298d1bb2bc134dc97f75a11c55b85ec">gl_sarray::operator[]</a> </p><div class="fragment"><div class="line">gl_sarray s{1,2,3,4,5};</div>
<div class="line"><span class="keywordtype">int</span> val = s[2]; </div>
<div class="line"><span class="comment">// val == 3</span></div>
</div><!-- fragment --><p>Or iterated <b>efficiently</b> using the <a class="el" href="classgraphlab_1_1gl__sarray.html#a6ccae5683be14bcfc41edbe389d47a97">gl_sarray::range_iterator</a> </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i: sa.range_iterator()) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_sarray_apply"></a>
Apply User Defined Function</h2>
<p>You can use <a class="el" href="classgraphlab_1_1gl__sarray.html#a35dd44242c71da9096d37536ad899654">gl_sarray::apply</a> to perform a "map" operation which takes each element of the <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> and returns a value of <a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a>. The return object is a <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> with the same size as the input <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a>.</p>
<p>For example, we can implement log transformation as follows: </p><div class="fragment"><div class="line"><span class="comment">// file logx.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/gl_sarray.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/toolkit_function_macros.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacegraphlab.html">graphlab</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> logx(<span class="keyword">const</span> <a class="code" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a>&amp; sa, <span class="keywordtype">double</span> log_base) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> base = log(log_base);</div>
<div class="line">  <span class="keywordflow">return</span> sa.<a class="code" href="classgraphlab_1_1gl__sarray.html#a35dd44242c71da9096d37536ad899654">apply</a>([base](<span class="keyword">const</span> <a class="code" href="classgraphlab_1_1flexible__type.html">flexible_type</a>&amp; element)-&gt;<a class="code" href="classgraphlab_1_1flexible__type.html">flexible_type</a> {</div>
<div class="line">    <span class="keywordflow">return</span> log((<span class="keywordtype">double</span>)element) / base;</div>
<div class="line">  }, <a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(logx, <span class="stringliteral">&quot;data&quot;</span>, <span class="stringliteral">&quot;base&quot;</span>)</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a> </div>
</div><!-- fragment --><h1><a class="anchor" id="sec_sframe_intro"></a>
SFrame</h1>
<p>SFrame (<a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a>) is a tabular, column-mutable dataframe object that can scale to big data.</p>
<p>The data in <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> is stored column-wise and each column is a <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a>, which is immutable. Although each column is immutable, the <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> objects are mutable in that columns can be added and removed with ease.</p>
<p>A <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> essentially acts as an ordered dictionary of <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> objects.</p>
<h2><a class="anchor" id="sec_sframe_usage"></a>
Using SFrame</h2>
<p>The <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> API is designed to very closely mimic the Python SFrame API and supports much of the Python-like capabilities, but in C++.</p>
<p><b>Column Creation And Referencing</b> </p><div class="fragment"><div class="line">gl_sframe sf;</div>
<div class="line">sf[<span class="stringliteral">&quot;a&quot;</span>] = {1,2,3,4,5}</div>
<div class="line">sf[<span class="stringliteral">&quot;b&quot;</span>] = a_5_element_sarray;</div>
<div class="line">sf[<span class="stringliteral">&quot;c&quot;</span>] = sf[<span class="stringliteral">&quot;a&quot;</span>] / sf[<span class="stringliteral">&quot;b&quot;</span>] + some_other_sarray;</div>
</div><!-- fragment --><p><b>Multi-Column Indexing</b> </p><div class="fragment"><div class="line">gl_sframe sf{ {<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5} },</div>
<div class="line">              {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>} },</div>
<div class="line">              {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}} };</div>
<div class="line">gl_sframe ret = sf[{<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>}]</div>
<div class="line"><span class="comment">// ret has 2 columns &quot;a&quot; and &quot;b&quot;</span></div>
</div><!-- fragment --><p><b>Logical Filter</b> </p><div class="fragment"><div class="line">gl_sframe sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div>
<div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}}}; </div>
<div class="line">gl_sframe t = sf[sf[<span class="stringliteral">&quot;a&quot;</span>] &lt; 3]</div>
<div class="line"><span class="comment">// t now has 2 columns. a: [1,2] b:[&quot;1&quot;,&quot;2&quot;]</span></div>
</div><!-- fragment --><p><b>Python Range Slicing</b> </p><div class="fragment"><div class="line">gl_sframe sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div>
<div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}}}; </div>
<div class="line">t = sf[{0,3}];</div>
<div class="line"><span class="comment">// t is the first 3 rows of sf</span></div>
</div><!-- fragment --><p><b>Join</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> animals = gl_sframe({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3, 4}},</div>
<div class="line">                          {<span class="stringliteral">&quot;name&quot;</span>, {<span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;sheep&quot;</span>, <span class="stringliteral">&quot;cow&quot;</span>}}});</div>
<div class="line"><span class="keyword">auto</span> sounds = gl_sframe({{<span class="stringliteral">&quot;id&quot;</span>, {1, 3, 4, 5}},</div>
<div class="line">                         {<span class="stringliteral">&quot;sound&quot;</span>, {<span class="stringliteral">&quot;woof&quot;</span>, <span class="stringliteral">&quot;baa&quot;</span>, <span class="stringliteral">&quot;moo&quot;</span>, <span class="stringliteral">&quot;oink&quot;</span>}}});</div>
<div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>}) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>}, <span class="stringliteral">&quot;left&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>}, <span class="stringliteral">&quot;right&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>}, <span class="stringliteral">&quot;outer&quot;</span>) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Produces output: </p><div class="fragment"><div class="line">+----+-------+-------+</div>
<div class="line">| <span class="keywordtype">id</span> |  name | sound |</div>
<div class="line">+----+-------+-------+</div>
<div class="line">| 1  |  dog  |  woof |</div>
<div class="line">| 3  | sheep |  baa  |</div>
<div class="line">| 4  |  cow  |  moo  |</div>
<div class="line">+----+-------+-------+</div>
<div class="line">[3 rows x 3 columns]</div>
<div class="line"></div>
<div class="line">+----+-------+-------+</div>
<div class="line">| <span class="keywordtype">id</span> |  name | sound |</div>
<div class="line">+----+-------+-------+</div>
<div class="line">| 1  |  dog  |  woof |</div>
<div class="line">| 3  | sheep |  baa  |</div>
<div class="line">| 4  |  cow  |  moo  |</div>
<div class="line">| 2  |  cat  |  None |</div>
<div class="line">+----+-------+-------+</div>
<div class="line">[4 rows x 3 columns]</div>
<div class="line"></div>
<div class="line">+----+-------+-------+</div>
<div class="line">| <span class="keywordtype">id</span> |  name | sound |</div>
<div class="line">+----+-------+-------+</div>
<div class="line">| 1  |  dog  |  woof |</div>
<div class="line">| 3  | sheep |  baa  |</div>
<div class="line">| 4  |  cow  |  moo  |</div>
<div class="line">| 5  |  None |  oink |</div>
<div class="line">+----+-------+-------+</div>
<div class="line">[4 rows x 3 columns]</div>
<div class="line"></div>
<div class="line">+----+-------+-------+</div>
<div class="line">| <span class="keywordtype">id</span> |  name | sound |</div>
<div class="line">+----+-------+-------+</div>
<div class="line">| 1  |  dog  |  woof |</div>
<div class="line">| 3  | sheep |  baa  |</div>
<div class="line">| 4  |  cow  |  moo  |</div>
<div class="line">| 5  |  None |  oink |</div>
<div class="line">| 2  |  cat  |  None |</div>
<div class="line">+----+-------+-------+</div>
<div class="line">[5 rows x 3 columns]</div>
</div><!-- fragment --><p><b>Sort</b> </p><div class="fragment"><div class="line">gl_sframe sf{ {<span class="stringliteral">&quot;a&quot;</span>, {1,3,2,1}},</div>
<div class="line">              {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>,<span class="stringliteral">&quot;c&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>}},</div>
<div class="line">              {<span class="stringliteral">&quot;c&quot;</span>, {<span class="stringliteral">&quot;x&quot;</span>,<span class="stringliteral">&quot;y&quot;</span>,<span class="stringliteral">&quot;z&quot;</span>,<span class="stringliteral">&quot;y&quot;</span>}} };</div>
<div class="line">gl_sframe sorted_by_a = sf.sort(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// rows in sorted_by_a are sorted by values of column &quot;a&quot;.</span></div>
</div><!-- fragment --><p>You can go to the <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> API doc page for a full list of functions.</p>
<p><b>Iterators</b></p>
<p>The <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> can be read <b>inefficiently</b> using <a class="el" href="classgraphlab_1_1gl__sframe.html#a8353813a41110ec29f05cc3394c2bfd1">gl_sframe::operator[]</a> </p><div class="fragment"><div class="line">gl_sframe sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div>
<div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}}}; </div>
<div class="line">std::vector&lt;flexible_type&gt; val = s[2]; </div>
<div class="line"><span class="comment">// val[0] == 3, val[1] == &quot;3&quot;</span></div>
</div><!-- fragment --><p>Or iterated <b>efficiently</b> using the <a class="el" href="classgraphlab_1_1gl__sframe.html#aaf6ea395ff1552bb5f031fb8f4c3e335">gl_sframe::range_iterator</a> </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;flexible_type&gt;&amp; row: sa.<a class="code" href="classgraphlab_1_1gl__sarray.html#a6ccae5683be14bcfc41edbe389d47a97">range_iterator</a>() {</div>
<div class="line">  ... </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_sframe_construction"></a>
Constructing SFrame</h2>
<p>The <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> can constructed in a variety of ways:</p><ul>
<li>If the data to be written is already in memory, it can be created using the <a class="el" href="classgraphlab_1_1gl__sframe.html#a15dfa904596b2d657e78e9bda2c3996c">gl_sframe constructor</a></li>
<li>If the columns are already in <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a>, it can be created using the other <a class="el" href="classgraphlab_1_1gl__sframe.html#ae33ee4df2225197c7c3f8988be56bfac">gl_sframe constructor</a></li>
<li>Otherwise, the <a class="el" href="classgraphlab_1_1gl__sframe__writer.html">gl_sframe_writer</a> can be used which provides a simple write interface.</li>
</ul>
<h2><a class="anchor" id="sec_sframe_writer"></a>
SFrame Writer Interface</h2>
<p><a class="el" href="classgraphlab_1_1gl__sframe__writer.html">gl_sframe_writer</a> Provides the ability to write <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a>. The <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> is internally cut into a collection of segments. Each segment can be written to independently, and the resultant SFrame is the effective concatenation of all the segments.</p>
<div class="fragment"><div class="line"><span class="comment">// Writes an SFrame of 4 segments, and 2 columns &quot;a&quot; and &quot;b&quot;, both of which</span></div>
<div class="line"><span class="comment">// are integers.  </span></div>
<div class="line">gl_sframe_writer writer({<span class="stringliteral">&quot;a&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>}, </div>
<div class="line">                        {<a class="code" href="group__group__gl__flexible__type.html#gaede798d6769152c1e46fd2c8983e5755">flex_type_enum</a>:<a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755a5d5cd46919fa987731fb2edefe0f2a0c">INTEGER</a>, <a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755a5d5cd46919fa987731fb2edefe0f2a0c">flex_type_enum::INTEGER</a>}, </div>
<div class="line">                        4);</div>
<div class="line"></div>
<div class="line"><span class="comment">// for each segment, write a bunch of (i, i) pair values.</span></div>
<div class="line"><span class="comment">// segment 0 has 10 0&#39;s, </span></div>
<div class="line"><span class="comment">// segment 1 has 10 1&#39;s,</span></div>
<div class="line"><span class="comment">// etc</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> seg = 0;seg &lt; 4; ++seg) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0;i &lt; 10; ++i) {</div>
<div class="line">    writer.write({i, i}, seg);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">gl_sframe sa = writer.close();</div>
<div class="line"><span class="comment">// sa is now an SFrame of 40 elements comprising of </span></div>
<div class="line"><span class="comment">// four consecutive sequences of (1,1) to (10,10)</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Different segments can be written safely in parallel.</dd>
<dd>
It is not safe to write to the same segment simultanously.</dd></dl>
<h2><a class="anchor" id="sec_sframe_apply"></a>
Apply User Defined Function</h2>
<p>You can use <a class="el" href="classgraphlab_1_1gl__sframe.html#a7e51da1718819c07e7d2afabf92f2b80">gl_sframe::apply</a> to perform a "map" operation which takes each row of the sframe and returns a value of <a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a>. The return object is a <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> whose size equals to number of rows of the <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a>.</p>
<p>This is often very useful for row-wise aggregation.</p>
<p>For example, we can use the following code for instance-wise normalization: </p><div class="fragment"><div class="line">gl_sframe sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div>
<div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div>
<div class="line"></div>
<div class="line">gl_sarray row_sum = sf.apply(</div>
<div class="line">  [](<span class="keyword">const</span> std::vector&lt;flexible_type&gt;&amp; row) { <span class="keywordflow">return</span> row[0] + row[1]; },</div>
<div class="line">  <a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>);</div>
<div class="line"></div>
<div class="line">gl_sframe sf_row_normalized;</div>
<div class="line">sf_row_normalized[<span class="stringliteral">&quot;a&quot;</span>] = sf[<span class="stringliteral">&quot;a&quot;</span>] / row_sum;</div>
<div class="line">sf_row_normalized[<span class="stringliteral">&quot;c&quot;</span>] = sf[<span class="stringliteral">&quot;c&quot;</span>] / row_sum;</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; sf_row_normalized &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">dtype: <span class="keywordtype">float</span></div>
<div class="line">Rows: 5</div>
<div class="line">[0.5, 0.5, 0.5, 0.5, 0.5]</div>
</div><!-- fragment --><p>The apply interface only support many to one functions, e.g. vector&lt;flexible_type&gt; -&gt; <a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a>. To make many to many transformation, i.e. <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> -&gt; <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a>, you can store the return value into a <a class="el" href="classgraphlab_1_1flexible__type.html">flexible_type</a> of type <a class="el" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a> and use <a class="el" href="classgraphlab_1_1gl__sarray.html#aee23b62db950d9a62b71ce8a0f6bfaf6">gl_sarray::unpack</a> to convert the resultant SArray into SFrame.</p>
<h2><a class="anchor" id="sec_sframe_groupby_aggregate"></a>
Groupby Aggregate</h2>
<p>Groupby aggregate is one of the most powerful operations for transforming datasets. SFrame offers a simple <a class="el" href="classgraphlab_1_1gl__sframe.html#aba7cf984043111d6606da93a5271177b">gl_sframe::groupby</a> interface with a large collection of aggregators ranging from standard ones like: <a class="el" href="namespacegraphlab_1_1aggregate.html#a7960880f3974c4eeaa1a31ac43679d31">aggregate::COUNT</a> and <a class="el" href="namespacegraphlab_1_1aggregate.html#a1b756fe52c0785528d69742b90bbaaa3">aggregate::MEAN</a>, to advanced ones like: <a class="el" href="namespacegraphlab_1_1aggregate.html#a4b325efee2eeab7619de1fa87cdf2abd">aggregate::QUANTILE</a> and <a class="el" href="namespacegraphlab_1_1aggregate.html#a260993326ebf2dadc6bef7d9a0f09644">aggregate::ARGMAX</a>.</p>
<p>For instance, we can get the mean and standard deviation of rating for each user: </p><div class="fragment"><div class="line">sf2 = sf.groupby({<span class="stringliteral">&quot;user&quot;</span>}, </div>
<div class="line">                 { {<span class="stringliteral">&quot;mean_rating&quot;</span>, <a class="code" href="namespacegraphlab_1_1aggregate.html#a1b756fe52c0785528d69742b90bbaaa3">aggregate::MEAN</a>(<span class="stringliteral">&quot;rating&quot;</span>)},</div>
<div class="line">                   {<span class="stringliteral">&quot;stdv_rating&quot;</span>, <a class="code" href="namespacegraphlab_1_1aggregate.html#a08189c40c60c136ab1973026c9c1fa0b">aggregate::STDV</a>(<span class="stringliteral">&quot;rating&quot;</span>)} });</div>
<div class="line"><span class="comment">// The result sf2 has three columns: user, mean_rating and stdv_rating</span></div>
</div><!-- fragment --><p>To extract the median: </p><div class="fragment"><div class="line">sf2 = sf.groupby( {<span class="stringliteral">&quot;user&quot;</span>}, </div>
<div class="line">                  { {<span class="stringliteral">&quot;rating_quantiles&quot;</span>, <a class="code" href="namespacegraphlab_1_1aggregate.html#a4b325efee2eeab7619de1fa87cdf2abd">aggregate::QUANTILE</a>(<span class="stringliteral">&quot;rating&quot;</span>, 0.5)} });</div>
<div class="line"><span class="comment">// The result sf2 has two columns: user, rating_quantiles</span></div>
</div><!-- fragment --><p>To extract a few quantiles: </p><div class="fragment"><div class="line">sf2 = sf.groupby({<span class="stringliteral">&quot;user&quot;</span>}, </div>
<div class="line">                 { {<span class="stringliteral">&quot;rating_quantiles&quot;</span>, <a class="code" href="namespacegraphlab_1_1aggregate.html#a4b325efee2eeab7619de1fa87cdf2abd">aggregate::QUANTILE</a>(<span class="stringliteral">&quot;rating&quot;</span>, {0.25,0.5,0.75})} });</div>
<div class="line"><span class="comment">// The result sf2 has two columns: user, rating_quantiles </span></div>
<div class="line"><span class="comment">// The rating_quantile has type vector wand length 3 </span></div>
</div><!-- fragment --><p>Or equivalently </p><div class="fragment"><div class="line">sf2 = sf.groupby({<span class="stringliteral">&quot;user&quot;</span>}, </div>
<div class="line">                 { {<span class="stringliteral">&quot;rating_quantiles&quot;</span>, <a class="code" href="namespacegraphlab_1_1aggregate.html#a4b325efee2eeab7619de1fa87cdf2abd">aggregate::QUANTILE</a>(<span class="stringliteral">&quot;rating&quot;</span>, {0.25,0.5,0.75})} });</div>
</div><!-- fragment --><p>To tet the movie with maximum rating per user: </p><div class="fragment"><div class="line">sf2 = sf.groupby({<span class="stringliteral">&quot;user&quot;</span>},</div>
<div class="line">                 { {<span class="stringliteral">&quot;best_movie&quot;</span>, <a class="code" href="namespacegraphlab_1_1aggregate.html#a260993326ebf2dadc6bef7d9a0f09644">aggregate::ARGMAX</a>(<span class="stringliteral">&quot;rating&quot;</span>, <span class="stringliteral">&quot;movie&quot;</span>)} });</div>
</div><!-- fragment --><h3><a class="anchor" id="sec_sframe_customized_groupby"></a>
User Defined Groupby Aggregator</h3>
<p>In addition to the builtin aggregators, you can easily define your own aggregators. To implement a new aggregator, start with a class which inherits from the base <a class="el" href="classgraphlab_1_1group__aggregate__value.html">group_aggregate_value</a>. The new aggregator class needs to implement the following pure virtual functions in the base class:</p><ul>
<li>Factory <a class="el" href="classgraphlab_1_1group__aggregate__value.html#a90520c6d5f53b9d1cecb234cab0483e0">group_aggregate_value::new_instance</a></li>
<li>Name <a class="el" href="classgraphlab_1_1group__aggregate__value.html#ab482a9db4b70a272a6c856587dfc77f7">group_aggregate_value::name</a></li>
<li>Supported types <a class="el" href="classgraphlab_1_1group__aggregate__value.html#ad8a27f9d817a4fbd0ea03e0ece510e75">group_aggregate_value::support_type</a></li>
<li>Return output type <a class="el" href="classgraphlab_1_1group__aggregate__value.html#ac7083f6c017a683d31bdeb71ba1ad5fe">group_aggregate_value::set_input_types</a></li>
<li>Update a single element <a class="el" href="classgraphlab_1_1group__aggregate__value.html#a5d7c1cbe6be43193df95c59c867532c5">group_aggregate_value::add_element_simple</a></li>
<li>Combine partial sums <a class="el" href="classgraphlab_1_1group__aggregate__value.html#adb99df8c294e0fd088c14ab649001ca4">group_aggregate_value::combine</a></li>
<li>Return final result <a class="el" href="classgraphlab_1_1group__aggregate__value.html#a4d2343b2f11b567e791373f9a9994c76">group_aggregate_value::emit</a></li>
<li>Save state of the aggregate value <a class="el" href="classgraphlab_1_1group__aggregate__value.html#a39bc7f1298a4f5ed9844ca0a77e4f5d3">group_aggregate_value::save</a></li>
<li>Load the state of the aggregate value <a class="el" href="classgraphlab_1_1group__aggregate__value.html#a8aabddc40ba45c7ec1ee943899e98822">group_aggregate_value::load</a></li>
</ul>
<p>Let's start with a simple example: implemeting a geometric mean aggregator, which takes values x0, x1, ... that belong to the same group, and return their geometric mean: <img class="formulaInl" alt="$ (x_0 * x_1 * ... * x_{n-1})^{1/n}$" src="form_0.png"/>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>geometric_mean: <span class="keyword">public</span> group_aggregate_value {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">  geometric_mean() { prod = 1.0; num_examples = 1; }</div>
<div class="line"></div>
<div class="line">  std::string name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;geometric_mean&quot;</span>; }</div>
<div class="line"></div>
<div class="line">  group_aggregate_value* new_instance()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> geometric_mean(); }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> add_element_simple(<span class="keyword">const</span> flexible_type&amp; flex) {</div>
<div class="line">    prod  *= (double) flex;</div>
<div class="line">    num_examples++;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> combine(<span class="keyword">const</span> group_aggregate_value&amp; other) {</div>
<div class="line">    prod *= ((<span class="keyword">const</span> geometric_mean&amp;)(other)).prod;</div>
<div class="line">    num_examples += ((<span class="keyword">const</span> geometric_mean&amp;)(other)).num_examples;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  flexible_type emit()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> pow(prod, 1.0 / num_examples);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">bool</span> support_type(<a class="code" href="group__group__gl__flexible__type.html#gaede798d6769152c1e46fd2c8983e5755">flex_type_enum</a> type)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> type == <a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755a5d5cd46919fa987731fb2edefe0f2a0c">flex_type_enum::INTEGER</a> || type == <a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__group__gl__flexible__type.html#gaede798d6769152c1e46fd2c8983e5755">flex_type_enum</a> set_input_types(<a class="code" href="group__group__gl__flexible__type.html#gaede798d6769152c1e46fd2c8983e5755">flex_type_enum</a> type) {</div>
<div class="line">    <span class="comment">// set nothing here because it&#39;s not needed</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group__gl__flexible__type.html#ggaede798d6769152c1e46fd2c8983e5755ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>; </div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> save(oarchive&amp; oarc)<span class="keyword"> const </span>{</div>
<div class="line">    oarc &lt;&lt; prod &lt;&lt; num_examples;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> load(iarchive&amp; iarc) {</div>
<div class="line">    iarc &gt;&gt; prod &gt;&gt; num_examples;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">double</span> prod;</div>
<div class="line">  <span class="keywordtype">size_t</span> num_examples;</div>
<div class="line">};</div>
</div><!-- fragment --><p>To apply the new aggregator we use the <a class="el" href="namespacegraphlab_1_1aggregate.html#a9854e1e224ec3a7058240f13751964c4">aggregate::make_aggregator</a> function. </p><div class="fragment"><div class="line">gl_sframe test_sframe { {<span class="stringliteral">&quot;key&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>,<span class="stringliteral">&quot;a&quot;</span>,<span class="stringliteral">&quot;a&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>}},</div>
<div class="line">                        {<span class="stringliteral">&quot;value&quot;</span>, {1,1,1,2,2,2}} }; </div>
<div class="line">gl_sframe result_sframe = test_sframe.groupby( {<span class="stringliteral">&quot;a&quot;</span>}, aggregate::make_aggregator&lt;geometric_mean&gt;({<span class="stringliteral">&quot;b&quot;</span>}) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// result_sframe will have two columns: &quot;key&quot; = [&quot;a&quot;, &quot;b&quot;], and &quot;value&quot; = &quot;1, 2&quot;;</span></div>
</div><!-- fragment --><p>Note that the new aggregator class cannot be directly published to python as a <code> graphlab.aggregate.GEOMETRIC_MEAN </code> and used by <code> graphlab.SFrame.groupby </code>. But we can wrap it into an extension function which we know how to publish. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/toolkit_function_macros.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;graphlab/sdk/gl_sframe.hpp&gt;</span></div>
<div class="line"></div>
<div class="line">gl_sframe groupby_geometric_mean(<span class="keyword">const</span> gl_sframe&amp; sf,</div>
<div class="line">                                 <span class="keyword">const</span> std::string&amp; key_column,</div>
<div class="line">                                 <span class="keyword">const</span> std::string&amp; value_column) {</div>
<div class="line">  gl_sframe result_sframe = sf.groupby( {key}, </div>
<div class="line">      {{<span class="stringliteral">&quot;output&quot;</span>, aggregate::make_aggregator&lt;geometric_mean&gt;({value_column})}} );</div>
<div class="line">  <span class="keywordflow">return</span> result_sframe;</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(groupby_geometric_mean, <span class="stringliteral">&quot;data&quot;</span>, <span class="stringliteral">&quot;key_column&quot;</span>, <span class="stringliteral">&quot;value_column&quot;</span>)</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --><p>The <a class="el" href="classgraphlab_1_1group__aggregate__value.html">group_aggregate_value</a> interface is flexible to implement complicated aggregators. For example, the aggregator can take multiple input columns, carry interesting states. For more details, please see the API doc of <a class="el" href="classgraphlab_1_1group__aggregate__value.html">group_aggregate_value</a>.</p>
<h2><a class="anchor" id="sec_sframe_reshape"></a>
Stack and Unstack (also known as reshape or pivot)</h2>
<p>It is easier to show how <b>stack</b> and <b>unstack</b> work by example.</p>
<p>Intuitively, <a class="el" href="classgraphlab_1_1gl__sframe.html#a3a1a9f6e29f7c90bec7ce0a8f525bf9c">gl_sframe::stack</a> converts a "wide" <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> to a "tall" <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a>.</p>
<p>Suppose 'sf' is an SFrame that contains a user and his/her friends, where 'friends' columns is an array type. Stack on 'friends' column would create a user/friend list for each user/friend pair: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  sf = gl_sframe({{<span class="stringliteral">&quot;topic&quot;</span>,{1,2,3}},</div>
<div class="line">                      {<span class="stringliteral">&quot;friends&quot;</span>,{{2,3,4}, {5,6}, {4,5,10,<a class="code" href="group__group__gl__flexible__type.html#ga6654fa4b4c00276e9491850b3cf7d90d">FLEX_UNDEFINED</a>}}}</div>
<div class="line">                     });</div>
<div class="line">std::cout &lt;&lt;  sf &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt;  sf.stack(<span class="stringliteral">&quot;friends&quot;</span>, <span class="stringliteral">&quot;friend&quot;</span>) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+------+------------------+</div>
<div class="line">| user |     friends      |</div>
<div class="line">+------+------------------+</div>
<div class="line">|  1   |     [2, 3, 4]    |</div>
<div class="line">|  2   |      [5, 6]      |</div>
<div class="line">|  3   | [4, 5, 10, None] |</div>
<div class="line">+------+------------------+</div>
<div class="line">[3 rows x 2 columns]</div>
<div class="line"></div>
<div class="line">+------+--------+</div>
<div class="line">| user | <span class="keyword">friend</span> |</div>
<div class="line">+------+--------+</div>
<div class="line">|  1   |  2     |</div>
<div class="line">|  1   |  3     |</div>
<div class="line">|  1   |  4     |</div>
<div class="line">|  2   |  5     |</div>
<div class="line">|  2   |  6     |</div>
<div class="line">|  3   |  4     |</div>
<div class="line">|  3   |  5     |</div>
<div class="line">|  3   |  1     |</div>
<div class="line">|  3   |  None  |</div>
<div class="line">+------+--------+</div>
<div class="line">[9 rows x 2 columns]</div>
</div><!-- fragment --><p><a class="el" href="classgraphlab_1_1gl__sframe.html#af0922a0bedeb435438eb93a173e262c4">gl_sframe::unstack</a> is the inverse operation of <a class="el" href="classgraphlab_1_1gl__sframe.html#a3a1a9f6e29f7c90bec7ce0a8f525bf9c">gl_sframe::stack</a>. It converts a "tall" <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> to a "wide" <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a>.</p>
<p>For instance: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  sf = gl_sframe({{<span class="stringliteral">&quot;friend&quot;</span>, {2, 3, 4, 5, 6, 4, 5, 2, 3}},</div>
<div class="line">                      {<span class="stringliteral">&quot;user&quot;</span>, {1, 1, 1, 2, 2, 2, 3, 4, 4}}});</div>
<div class="line">std::cout &lt;&lt;  sf.unstack(<span class="stringliteral">&quot;friend&quot;</span>, <span class="stringliteral">&quot;friends&quot;</span>) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+------+-----------------------------+</div>
<div class="line">| user |           friends           |</div>
<div class="line">+------+-----------------------------+</div>
<div class="line">|  3   |            [5.0]            |</div>
<div class="line">|  1   |       [2.0, 4.0, 3.0]       |</div>
<div class="line">|  2   |       [5.0, 6.0, 4.0]       |</div>
<div class="line">|  4   |          [2.0, 3.0]         |</div>
<div class="line">+------+-----------------------------+</div>
<div class="line">[4 rows x 2 columns]</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_sframe_python_binding"></a>
Python Binding</h2>
<p>When used as an input argument in an SDK function, it permits a Python SFrame to be passed as an argument. When used in an output argument, it will return a Python SFrame.</p>
<p>For instance: </p><div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Compiled as example.so</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line">gl_sframe add_ones_column(<span class="keyword">const</span> gl_sframe&amp; data) {</div>
<div class="line">  gl_sframe sf = data;</div>
<div class="line">  sf[<span class="stringliteral">&quot;ones&quot;</span>] = 1;</div>
<div class="line">  <span class="keywordflow">return</span> sf;</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(add_ones_column, <span class="stringliteral">&quot;data&quot;</span>);</div>
<div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div>
</div><!-- fragment --><p>Will allow this to be done in Python: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> graphlab <span class="keyword">as</span> gl</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">import</span> example</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;sa = SFrame({<span class="stringliteral">&quot;a&quot;</span>:[1,2,3,4,5]})</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ret = example.add_ones_column(sa)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"># ret now has two columns. &quot;a&quot;:[1,2,3,4,5] and &quot;ones&quot;:[1,1,1,1,1]</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sec_detail"></a>
Details</h1>
<p>The <a class="el" href="classgraphlab_1_1gl__sarray.html">gl_sarray</a> and <a class="el" href="classgraphlab_1_1gl__sframe.html">gl_sframe</a> are lazy evaluated behind the scenes to minimize disk access. This may have the unfortunate effect of hiding errors until materialization is forced to occur. i.e. it might be some time much later in your code that errors will trigger.</p>
<p>However, not all operations are lazy and certain operations will force materialization, and that is a constant target for optimization.</p>
<p>If you want to force materialization yourself, use <a class="el" href="classgraphlab_1_1gl__sframe.html#a7c9c97ad450879b796754ccc6bbe42a0">gl_sframe::materialize()</a> (<a class="el" href="classgraphlab_1_1gl__sarray.html#aa151a283df3193542eb91c3d6d16704c">gl_sarray::materialize()</a>). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 4 2014 11:53:02 for GraphLab Create SDK API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
